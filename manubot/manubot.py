import argparse
import collections
import datetime
import json
import logging
import os
import pathlib
import sys
import textwrap

import jinja2
import pandas
import yaml

from manubot.manuscript import (
    get_citation_strings,
    get_manuscript_stats,
    get_text,
    replace_citations_strings_with_ids,
)
from manubot.citations import (
    citation_to_citeproc,
    get_citation_id,
    is_valid_citation_string,
    standardize_citation,
)


def parse_arguments():
    """
    Read and process command line arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--content-directory', type=pathlib.Path, required=True,
                        help='directory where manuscript content files are located')
    parser.add_argument('--output-directory', type=pathlib.Path, required=True,
                        help='directory to output files generated by this script')
    # parser.add_argument('--template-variables-path', type=pathlib.Path)
    # parser.add_argument('--clear-cache', action='store_true',
    #                     default='REFRESH_METADATA_CACHE' in os.environ)
    parser.add_argument('--log-level', default='WARNING',
                        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                        help='Set the logging level for stderr logging')
    args = parser.parse_args()
    args_dict = vars(args)

    # Set paths for content
    content_dir = args.content_directory
    args_dict['citation_tags_path'] = content_dir.joinpath('citation-tags.tsv')
    args_dict['meta_yaml_path'] = content_dir.joinpath('metadata.yaml')
    args_dict['manual_references_path'] = content_dir.joinpath('manual-references.json')

    # Set paths for output
    output_dir = args.output_directory
    output_dir.mkdir(exist_ok=True)
    args_dict['manuscript_path'] = output_dir.joinpath('manuscript.md')
    args_dict['citations_path'] = output_dir.joinpath('citations.tsv')
    args_dict['references_path'] = output_dir.joinpath('references.json')
    args_dict['variables_path'] = output_dir.joinpath('variables.json')

    return args


def read_manual_references(path):
    """
    Read manual references (overrides) in JSON CSL specified by a pathlib.Path.
    """
    if not path.is_file():
        return dict()
    with path.open() as read_file:
        manual_refs = json.load(read_file)
    for csl_item in manual_refs:
        standard_citation = csl_item.pop('standard_citation')
        csl_item['id'] = get_citation_id(standard_citation)
    return manual_refs


def check_collisions(citation_df):
    """
    Check for citation_id hash collisions
    """
    collision_df = citation_df[['standard_citation', 'citation_id']].drop_duplicates()
    collision_df = collision_df[collision_df.citation_id.duplicated(keep=False)]
    if not collision_df.empty:
        logging.error(f'OMF! Hash collision. Congratulations.\n{collision_df}')
    return collision_df


def check_multiple_citation_strings(citation_df):
    """
    Identify different citation strings referring the the same reference.
    """
    message = textwrap.dedent(f'''\
    {len(citation_df)} unique citations strings extracted from text
    {citation_df.standard_citation.nunique()} unique standard citations\
    ''')
    logging.info(message)
    multi_df = citation_df[citation_df.standard_citation.duplicated(keep=False)]
    if not multi_df.empty:
        table = multi_df.to_string(index=False, columns=['standard_citation', 'string'])
        logging.warning(f'Multiple citation strings detected for the same reference:\n{table}')
    return multi_df


def get_metadata_and_variables(args):
    """
    Process metadata.yaml and create variables available for jinja2 templating.
    """
    # Generated manuscript variables
    variables = collections.OrderedDict()

    # Read metadata which contains pandoc_yaml_metadata
    # as well as author_info.
    with args.meta_yaml_path.open() as read_file:
        metadata = yaml.load(read_file)

    # Add date to metadata
    today = datetime.date.today()
    metadata['date-meta'] = today.isoformat()
    variables['date'] = today.strftime('%B %e, %Y')

    # Process authors metadata
    authors = metadata.pop('author_info')
    metadata['author-meta'] = [author['name'] for author in authors]
    variables['authors'] = authors

    # Set repository version metadata for CI builds only
    repo_slug = os.getenv('TRAVIS_REPO_SLUG')
    commit = os.getenv('TRAVIS_COMMIT')
    if repo_slug and commit:
        variables['ci_source'] = {
            'repo_slug': repo_slug,
            'commit': commit,
        }

    # Future: Update variables with user-provided variables here
    return metadata, variables


def get_citation_df(args, text):
    """
    Generate citation_df and save it to 'citations.tsv'.
    """
    citation_df = pandas.DataFrame(
        {'string': get_citation_strings(text)}
    )
    if args.citation_tags_path.is_file():
        tag_df = pandas.read_table(args.citation_tags_path)
        tag_df['string'] = '@tag:' + tag_df.tag
        for citation in tag_df.citation:
            is_valid_citation_string('@' + citation)
        citation_df = citation_df.merge(tag_df[['string', 'citation']], how='left')
    else:
        citation_df['citation'] = None
    citation_df.citation.fillna(citation_df.string.str.lstrip('@'), inplace=True)
    citation_df['standard_citation'] = citation_df.citation.map(standardize_citation)
    citation_df['citation_id'] = citation_df.standard_citation.map(get_citation_id)
    citation_df = citation_df.sort_values(['standard_citation', 'citation'])
    citation_df.to_csv(args.citations_path, sep='\t', index=False)
    check_collisions(citation_df)
    check_multiple_citation_strings(citation_df)
    return citation_df


def generate_csl_items(args, citation_df):
    """
    General CSL (citeproc) items for standard_citations in citation_df.
    Writes references.json to disk and logs warnings for potential problems.
    """
    # Read manual references (overrides) in JSON CSL
    manual_refs = read_manual_references(args.manual_references_path)

    csl_items = list()
    failures = list()
    for citation in citation_df.standard_citation.unique():
        if citation in manual_refs:
            csl_items.append(manual_refs[citation])
            continue
        try:
            citeproc = citation_to_citeproc(citation)
            csl_items.append(citeproc)
        except Exception as error:
            logging.exception(f'Citeproc retrieval failure for {citation}')
            failures.append(citation)

    if failures:
        message = 'Citeproc retrieval failed for:\n{}'.format(
            '\n'.join(failures))
        logging.error(message)

    # Write JSON CSL bibliography for Pandoc.
    with args.references_path.open('w') as write_file:
        json.dump(csl_items, write_file, indent=2, ensure_ascii=False)
    return csl_items


def template_with_jinja2(text, variables):
    """
    Template using jinja2 with the variables dictionary unpacked as keyword
    arguments.
    """
    jinja_environment = jinja2.Environment(
        loader=jinja2.BaseLoader(),
        comment_start_string='{##',
        comment_end_string='##}',
    )
    template = jinja_environment.from_string(text)
    return template.render(**variables)


def prepare_manuscript(args):
    """
    Compile manuscript, creating manuscript.md and references.json as inputs
    for pandoc.
    """
    text = get_text(args.content_directory)
    citation_df = get_citation_df(args, text)

    generate_csl_items(args, citation_df)

    citation_string_to_id = collections.OrderedDict(
        zip(citation_df.string, citation_df.citation_id))
    text = replace_citations_strings_with_ids(text, citation_string_to_id)

    metadata, variables = get_metadata_and_variables(args)
    variables['manuscript_stats'] = get_manuscript_stats(text, citation_df)
    with args.variables_path.open('w') as write_file:
        json.dump(variables, write_file, indent=2)

    text = template_with_jinja2(text, variables)

    # Write manuscript for pandoc
    with args.manuscript_path.open('w') as write_file:
        yaml.dump(metadata, write_file, default_flow_style=False,
                  explicit_start=True, explicit_end=True)
        write_file.write('\n')
        write_file.write(text)


def main():
    """
    Called as a console_scripts entry point in setup.py. This function defines
    the manubot command line script.
    """
    args = parse_arguments()

    # Track if message gets logged with severity of error or greater
    # See https://stackoverflow.com/a/45446664/4651668
    import errorhandler
    error_handler = errorhandler.ErrorHandler()

    # Log to stderr
    logger = logging.getLogger()
    logger.setLevel(getattr(logging, args.log_level))
    stream_handler = logging.StreamHandler(stream=sys.stderr)
    stream_handler.setFormatter(logging.Formatter('## {levelname}\n{message}', style='{'))
    logger.addHandler(stream_handler)

    prepare_manuscript(args)

    if error_handler.fired:
        logging.critical('Failure: exiting with code 1 due to logged errors')
        raise SystemExit(1)
